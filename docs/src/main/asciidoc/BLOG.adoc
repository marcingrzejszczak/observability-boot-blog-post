The Spring Observability Team has been working on adding Observability support for Spring Applications for quite some time, and we are pleased to inform you that this feature will be generally available with Spring Framework 6 and Spring Boot 3!

What is Observability? In our understanding that's _"how well you can understand the internals of your system by examining its outputs"_. We believe that the interconnection between metrics, logging, and distributed tracing gives you the ability to reason about the state of your system in order to debug exceptions and latency in your applications. You can watch more about what we think that Observability is in https://tanzu.vmware.com/developer/tv/enlightning/10/[this episode of Enlightning with Jonatan Ivanov].

The upcoming Spring Boot `3.0.0-RC1` release will contain numerous autoconfigurations for improved metrics with https://micrometer.io/docs[Micrometer] and new distributed tracing support with https://micrometer.io/docs/tracing[Micrometer Tracing]. The most notable changes are that it will contain inbuilt support for log correlation, https://www.w3.org/TR/trace-context/[W3C context propagation] will be the default propagation type, and we are adding remote baggage (key-values that would be automatically sent over the wire) support.

We have been changing the API a lot over the course of this year. The most important change is that we have introduced a new API in Micrometer: the Observation API.

> The idea of its founding was that we want the users to instrument their code once using a single API and have multiple benefits out of it (e.g. metrics, tracing, logging).

This blog post details what you need to know to about that API and how you can use it to provide more insights into your application.

= How Does Micrometer Observation Work?

On a high level, the lifecycle of an Observation looks as follows:

[source]
----
        Observation           Observation                   Observation                    Observation
        Context               Context                       Context                        Context
Created ----------> Started ----------> (Optionally) Error ----------> (Optionally) Event ----------> Stopped
                           |
                           |
                            \---------->   Scope Started   ----------> Scope Finished
                              Observation                  Observation
                              Context                      Context
----

For any Observation to happen, you need to register `ObservationHandler` objects through an `ObservationRegistry`. An `ObservationHandler` reacts only to supported implementations of an `Observation.Context` and can create timers, spans, and logs by reacting to the lifecycle events of an Observation such as

* `start` - Observation has been started. Happens when the `Observation#start()` method gets called.
* `stop` - Observation has been stopped. Happens when the `Observation#stop()` method gets called.
* `error` - An error occurred while observing. Happens when the `Observation#error(exception)` method gets called.
* `event` - An event happened when observing. Happens when the `Observation#event(event)` method gets called.
* `scope started` - Observation opens a Scope. The Scope must be closed when no longer used. Handlers can create thread local variables on start that are cleared upon closing of the scope. Happens when the `Observation#openScope()` method gets called.
* `scope stopped` - Observation stops a Scope. Happens when the `Observation.Scope#close()` method gets called.

Whenever a state transition happens, an `ObservationHandler` method (such as `onStart(T extends Observation.Context ctx)`, `onStop(T extends Observation.Context ctx)`, and so on) are called. To pass state between the handler methods, you can use the `Observation.Context`.

To separate Observation lifecycle operations from an Observation configuration (such as names and low and high cardinality tags), you can use the `ObservationConvention` that provides an easy way of overriding the default naming conventions.

IMPORTANT:  *High cardinality* means that a key value will have an unbounded number of possible values. An HTTP URL is a good
example of such a key value (e.g. `/foo/bar`, `/foo/baz` etc.). *Low cardinality* means that a key value will  have a bounded number of possible values. A templated HTTP URL is a good example of such a key value (e.g. `/foo/{userId}`).

= Building Your First Observed Application

The easiest way to get started is to create a new project from https://start.spring.io. Make sure to select Spring Boot 3.0.0-RC1 and your favorite build tool.

We will build a Spring WebMvc server application and a client that will call the server using RestTemplate. We start with the server side.

== WebMvc Server Setup

Since we want to start an HTTP server, we have to pick the `org.springframework.boot:spring-boot-starter-web` dependency.

To add aspect support, we need to add the `org.springframework.boot:spring-boot-starter-aop` dependency.

You need to chose `spring-boot-starter-actuator` to add observation features to your application (to add https://micrometer.io[Micrometer] to the classpath).

Now it's time to add observability related features!

* *Metrics*
** For Micrometer metrics with Prometheus, we need to add the `io.micrometer:micrometer-registry-prometheus` dependency.
* *Tracing*
** For *Tracing Context Propagation*, with Micrometer Tracing, we need to pick a *tracer* bridge (*tracer* is a library that is used to handle the lifecycle of a span). We will pick https://zipkin.io[Zipkin Brave] by adding the `io.micrometer:micrometer-tracing-bridge-brave`.
** For *Latency Visualization*, we need to send the finished spans in some format to a server. In our case we will produce an Zipkin-compliant span. To achieve that, we need to add a `io.zipkin.reporter2:zipkin-reporter-brave` dependency.
* *Logs*
** Since we have tracing-related metrics on the classpath, the logs will be automatically correlated (they will contain a unique trace identifier). Now we need to ship the logs. For this demo, we will ship them to https://grafana.com/oss/loki/[Grafana Loki]. We can achieve that by adding the `com.github.loki4j:loki-logback-appender:latest.release` dependency.

IMPORTANT: If you are new to tracing, we need to quickly define a couple of basic terms. You can wrap any operation in a `span`. It has a unique `span id`, contains timing information and some additional metadata (key-value pairs). Because you can produce child spans from spans, the whole tree of spans forms a `trace` that shares the same `trace id` (that is a correlation identifier).

Now we need to add some configuration. We will set up `actuator` and `metrics` to publish percentiles histograms, and we will redefine the logging pattern to include the trace and span identifiers.

./src/main/resources/application.properties
[source,properties]
----
include::../../../../server/src/main/resources/application.properties[]
----

Since we will be running the https://grafana.com/grafana/[Grafana] stack with https://grafana.com/oss/loki/[Loki] and https://grafana.com/oss/tempo/[Tempo] locally, we will configure the `loki-logback-appender` to send logs to the local instance of loki.

./src/main/resources/logback-spring.xml
[source,xml]
----
include::../../../../server/src/main/resources/logback-spring.xml[]
----

== WebMvc Server Code

Time to write some server-side code! We would like to achieve full observability of our application, including metrics, tracing, and additional logging.

To begin with, we write a controller that will log a message to the console and delegate work to a service.

.MyController.java
[source,java]
----
include::../../../../server/src/main/java/com/example/server/ServerApplication.java[tags=controller]
----

We would like to have some detailed observation of the `MyService#foo` method. Thanks to having added AOP support, we can use the `@Observed` annotation -- we can just register a `ObservedAspect` bean.

.MyConfiguration.java
[source,java]
----
@Configuration(proxyBeanMethods = false)
class MyConfiguration {
include::../../../../server/src/main/java/com/example/server/ServerApplication.java[tags=aspect]
}
----

.MyService.java
[source,java]
----
include::../../../../server/src/main/java/com/example/server/ServerApplication.java[tags=service]
----

With metrics and tracing on the classpath, having this annotation will lead to creation of a `timer`, a `long task timer`, and a `span`. The timer would be named `foo.metric`, the long task timer would be named `foo.metric.active`, and a span would be named `my-contextual-name`.

What about logs? We do not want to write the logging statements manually whenever an observation takes place. What we can do is to create a dedicated handler that will log some text for each observation.

.MyHandler.java
[source,java]
----
include::../../../../server/src/main/java/com/example/server/ServerApplication.java[tags=handler]
----

You might wonder what you should do to have the observability turned on for the controllers? You can register one bean and be ready to go. In the future we, will provide a more automated solution.

// TODO: Remove this section once https://github.com/spring-projects/spring-boot/issues/32538 is merged

.MyConfiguration.java
[source,java]
----
@Configuration(proxyBeanMethods = false)
class MyConfiguration {
include::../../../../server/src/main/java/com/example/server/ServerApplication.java[tags=filter]
}
----

That is it! Time for the client side.

== RestTemplate Client Application Setup

As before, we will add the `spring-boot-starter-web` and `spring-boot-starter-actuator` dependencies to have a web server running and Micrometer support added.

Time to add observability related features!

* *Metrics*
** For Micrometer metrics with Prometheus, we need to add the `io.micrometer:micrometer-registry-prometheus` dependency.
* *Tracing*
** For *Tracing Context Propagation*, with Micrometer Tracing, we need to pick a *tracer* bridge. We will pick https://opentelemetry.io[OpenTelemetry] by adding the `io.micrometer:micrometer-tracing-bridge-otel`.
** For *Latency Visualization*, we need to send the finished spans in some format to a server. In our case, we will produce an OpenZipkin compliant span. To achieve that, we need to add a `io.opentelemetry:opentelemetry-exporter-zipkin` dependency
* *Logs*
** As previously, we will add the `com.github.loki4j:loki-logback-appender:latest.release` dependency to ship logs to Loki.

Now we need to add some configuration. We will have almost identical configuration as on the server side. However, we will also add `management.tracing.sampling.probability=1.0` to ensure that all spans are always sent to the latency analysis server.

./src/main/resources/application.properties
[source,properties]
----
include::../../../../client/src/main/resources/application.properties[]
----

The Loki Appender configuration looks exactly the same.

./src/main/resources/logback-spring.xml
[source,xml]
----
include::../../../../client/src/main/resources/logback-spring.xml[]
----

== RestTemplate Application Client Code

Now it is time to write some client-side code! We will send a request with `RestTemplate` to the server side, and we would like to achieve the full observability of our application, including metrics and tracing.

To begin, we need a `RestTemplate` bean that will be automatically instrumented by Spring Boot. Remember to inject the `RestTemplateBuilder` and construct a `RestTemplate` instance from the builder.

.MyConfiguration.java
[source,java]
----
@Configuration(proxyBeanMethods = false)
class MyConfiguration {
include::../../../../client/src/main/java/com/example/client/ClientApplication.java[tags=rest-template]
}
----

Now we can write a `CommandLineRunner` bean that will be wrapped by using the Observation API and that will send a request to the server side. All parts of the API are described in more detail in the following snippet.

.MyConfiguration.java
[source,java]
----
@Configuration(proxyBeanMethods = false)
class MyConfiguration {
include::../../../../client/src/main/java/com/example/client/ClientApplication.java[tags=runner]
}
----

=== Limitations

The Spring Boot AutoConfiguration for WebMvc Observability is not yet there - that's why we needed to set things up manually. For more information check this https://github.com/spring-projects/spring-boot/issues/32538[issue].

For the Spring Boot Exemplars AutoConfiguration to work properly we need to wait for https://github.com/spring-projects/spring-boot/pull/32399[this PR] and https://github.com/spring-projects/spring-boot/pull/32415[this PR] to be merged. Until then we need to create https://github.com/marcingrzejszczak/observability-boot-blog-post/blob/main/server/src/main/java/com/example/server/ExemplarsConfiguration.java[such configuration] manually.

== Running It All Together

We have prepared a Docker setup of the whole Observability infrastructure under https://github.com/marcingrzejszczak/observability-boot-blog-post[this link]. Follow these steps to run the infrastructure and both applications:

include::../../../../RUNNING.adoc[]

== Running It All Together using Spring Native

To better understand how Spring Boot supports Native please read https://spring.io/blog/2022/09/26/native-support-in-spring-boot-3-0-0-m5[this excellent blog post]. We will reuse that knowledge to run the previously created applications using Spring Native.

=== Building

To build the applications, you need GraalVM on your path. If you use `SDKMan`, invoke the following:

[indent=0]
----
sdk install java 22.2.r17-nik
----

See also https://www.graalvm.org/java/quickstart/[GraalVM Quickstart]

To build the application with Maven, you need to enable the `native` profile:

[indent=0]
----
$ ./mvnw -Pnative clean package
----

=== Running

Run the server side application first

[indent=0]
----
$ ./server/target/server
----

Next, run the client side application.

[indent=0]
----
$ ./client/target/client
----

You should get a similar output to this one

.Client side logs
[indent=0]
----
2022-10-10T12:57:17.712+02:00  INFO [client,,] 82009 --- [           main] com.example.client.ClientApplication     : Starting ClientApplication using Java 17.0.4 on marcin-precision5560 with PID 82009 (/home/marcin/repo/observability/blogs/bootRc1/client/target/client started by marcin in /home/marcin/repo/observability/blogs/bootRc1)
2022-10-10T12:57:17.712+02:00  INFO [client,,] 82009 --- [           main] com.example.client.ClientApplication     : No active profile set, falling back to 1 default profile: "default"
2022-10-10T12:57:17.723+02:00  INFO [client,,] 82009 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 6543 (http)
2022-10-10T12:57:17.723+02:00  INFO [client,,] 82009 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2022-10-10T12:57:17.723+02:00  INFO [client,,] 82009 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.0.23]
2022-10-10T12:57:17.727+02:00  INFO [client,,] 82009 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2022-10-10T12:57:17.727+02:00  INFO [client,,] 82009 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 15 ms
2022-10-10T12:57:17.731+02:00  WARN [client,,] 82009 --- [           main] i.m.c.i.binder.jvm.JvmGcMetrics          : GC notifications will not be available because MemoryPoolMXBeans are not provided by the JVM
2022-10-10T12:57:17.781+02:00  INFO [client,,] 82009 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 15 endpoint(s) beneath base path '/actuator'
2022-10-10T12:57:17.783+02:00  INFO [client,,] 82009 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 6543 (http) with context path ''
2022-10-10T12:57:17.783+02:00  INFO [client,,] 82009 --- [           main] com.example.client.ClientApplication     : Started ClientApplication in 0.077 seconds (process running for 0.079)
2022-10-10T12:57:17.784+02:00  INFO [client,27c1113e4276c4173daec3675f536bf4,e0f2db8b983607d8] 82009 --- [           main] com.example.client.ClientApplication     : Will send a request to the server
2022-10-10T12:57:17.820+02:00  INFO [client,27c1113e4276c4173daec3675f536bf4,e0f2db8b983607d8] 82009 --- [           main] com.example.client.ClientApplication     : Got response [foo]
2022-10-10T12:57:18.966+02:00  INFO [client,,] 82009 --- [nio-6543-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2022-10-10T12:57:18.966+02:00  INFO [client,,] 82009 --- [nio-6543-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2022-10-10T12:57:18.966+02:00  INFO [client,,] 82009 --- [nio-6543-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 0 ms
----

.Server side logs
[indent=0]
----
2022-10-10T12:57:07.200+02:00  INFO [server,,] 81760 --- [           main] com.example.server.ServerApplication     : Starting ServerApplication using Java 17.0.4 on marcin-precision5560 with PID 81760 (/home/marcin/repo/observability/blogs/bootRc1/server/target/server started by marcin in /home/marcin/repo/observability/blogs/bootRc1)
2022-10-10T12:57:07.201+02:00  INFO [server,,] 81760 --- [           main] com.example.server.ServerApplication     : No active profile set, falling back to 1 default profile: "default"
2022-10-10T12:57:07.213+02:00  INFO [server,,] 81760 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 7654 (http)
2022-10-10T12:57:07.213+02:00  INFO [server,,] 81760 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2022-10-10T12:57:07.213+02:00  INFO [server,,] 81760 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.0.23]
2022-10-10T12:57:07.217+02:00  INFO [server,,] 81760 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2022-10-10T12:57:07.217+02:00  INFO [server,,] 81760 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 16 ms
2022-10-10T12:57:07.222+02:00  WARN [server,,] 81760 --- [           main] i.m.c.i.binder.jvm.JvmGcMetrics          : GC notifications will not be available because MemoryPoolMXBeans are not provided by the JVM
2022-10-10T12:57:07.278+02:00  INFO [server,,] 81760 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 15 endpoint(s) beneath base path '/actuator'
2022-10-10T12:57:07.280+02:00  INFO [server,,] 81760 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 7654 (http) with context path ''
2022-10-10T12:57:07.281+02:00  INFO [server,,] 81760 --- [           main] com.example.server.ServerApplication     : Started ServerApplication in 0.086 seconds (process running for 0.088)
2022-10-10T12:57:07.639+02:00  INFO [server,,] 81760 --- [nio-7654-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2022-10-10T12:57:07.639+02:00  INFO [server,,] 81760 --- [nio-7654-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2022-10-10T12:57:07.640+02:00  INFO [server,,] 81760 --- [nio-7654-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2022-10-10T12:57:17.785+02:00  INFO [server,,] 81760 --- [nio-7654-exec-8] com.example.server.MyHandler             : Before running the observation for context [http.server.requests]
2022-10-10T12:57:17.785+02:00  INFO [server,27c1113e4276c4173daec3675f536bf4,9affba5698490e2d] 81760 --- [nio-7654-exec-8] com.example.server.MyController          : Got a request
2022-10-10T12:57:17.820+02:00  INFO [server,,] 81760 --- [nio-7654-exec-8] com.example.server.MyHandler             : After running the observation for context [http.server.requests]
----

You can check Grafana for metrics and traces. Read the limitations section below on why you won't find any pushed logs to Loki.

=== Native Support Limitations

You will not see logs being pushed to Loki just yet. For more information look into https://github.com/spring-projects/spring-boot/issues/25847[this issue].

On the client side we needed to provide the `reflect-config.js` configuration manually. For more information look into https://github.com/open-telemetry/opentelemetry-java/pull/4832[this PR].

= Summary

In this blog post, we have managed to give you an introduction of the main concepts behind the Micrometer Observability API. We have also shown you how you can create observations by using the Observation API and annotations. You were also able to visualize the latency, see the correlated logs, and check the metrics that come from you Spring Boot applications.

You were also able to observe your applications using native images via Spring Native.

= Next Steps

Based on community feedback, we will continue to improve our Observability story. We intend to go GA in November this year.

This is an exciting time for us. We would again like to thank everyone who has already contributed and reported feedback, and we look forward to further feedback (don't hesitate to check out Spring Boot's latest snapshots)!
